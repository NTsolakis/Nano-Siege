<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Nano‑Siege Launcher</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    *{box-sizing:border-box;margin:0;padding:0}
    html,body{height:100%;width:100%;background:#050611;color:#e6f7ff;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif;overflow:hidden}
    body{display:flex;align-items:center;justify-content:center}
    .bg{position:fixed;inset:0;background-color:#050611;filter:brightness(0.45);z-index:0}
    .overlay{position:relative;z-index:1;display:flex;align-items:center;justify-content:center;width:100%;height:100%;padding:12px}
    .card{min-width:320px;max-width:520px;background:rgba(8,10,26,0.92);border-radius:14px;border:1px solid rgba(96,255,255,0.5);box-shadow:0 0 40px rgba(0,0,0,0.85);padding:20px 24px;text-align:center}
    .title{font-size:26px;letter-spacing:0.12em;text-transform:uppercase;margin-bottom:4px;color:#8cf5ff;text-shadow:0 0 12px rgba(0,255,255,0.55)}
    .subtitle{font-size:13px;color:#9fb4ff;margin-bottom:16px}
    .status{font-size:14px;color:#e6f7ff;margin-bottom:4px}
    .version{font-size:12px;color:#8fb7ff;margin-bottom:8px}
    .dl-wrap{margin:4px 0 10px 0;font-size:11px;color:#c5e2ff}
    .dl-bar{position:relative;width:100%;height:6px;border-radius:999px;background:rgba(8,20,40,0.85);overflow:hidden;border:1px solid rgba(120,180,255,0.45);box-shadow:0 0 10px rgba(0,0,0,0.75) inset}
    .dl-fill{position:absolute;inset:0;width:0%;background:linear-gradient(90deg,#12b5ff,#54ffe6);box-shadow:0 0 12px rgba(0,255,255,0.55)}
    .dl-text{margin-top:4px;min-height:14px;color:#9fb7ff}
    .signin-wrap{margin:8px 0 6px 0;text-align:left;font-size:12px;color:#c5e2ff}
    .signin-grid{display:flex;flex-wrap:wrap;gap:8px}
    .signin-field{flex:1 1 140px;display:flex;flex-direction:column;gap:2px}
    .signin-field label{font-size:11px;color:#9fb7ff}
    .signin-field input{padding:4px 8px;border-radius:6px;border:1px solid rgba(142,189,255,0.8);background:rgba(4,10,24,0.9);color:#e6f7ff;font-size:12px}
    .signin-options{margin-top:6px;font-size:11px;color:#9fb7ff}
    .signin-status{margin-top:4px;min-height:14px;font-size:11px}
    .buttons{display:flex;justify-content:center;gap:10px;margin-top:8px}
    button{min-width:90px;padding:8px 18px;border-radius:999px;border:1px solid rgba(96,255,255,0.7);background:linear-gradient(135deg,#12b5ff,#54ffe6);color:#02131f;font-weight:600;font-size:14px;cursor:pointer;box-shadow:0 0 12px rgba(0,255,255,0.35);transition:transform 0.1s ease,box-shadow 0.1s ease,filter 0.1s ease,background 0.2s}
    button.secondary{background:rgba(4,10,24,0.9);color:#c7d7ff;border-color:rgba(142,189,255,0.8);box-shadow:none}
    button:disabled{opacity:0.6;cursor:default;box-shadow:none}
    button:not(:disabled):hover{transform:translateY(-1px);box-shadow:0 0 16px rgba(0,255,255,0.5);filter:brightness(1.05)}
    button.secondary:not(:disabled):hover{box-shadow:0 0 14px rgba(150,190,255,0.45)}
    .fs-row{margin-top:8px;font-size:11px;color:#9fb7ff;display:flex;justify-content:center}
    .fs-toggle{display:inline-flex;align-items:center;gap:6px;cursor:pointer}
    .fs-toggle input{accent-color:#54ffe6}
    .fs-label{user-select:none}
    .footer{margin-top:12px;font-size:11px;color:#6f88b5;opacity:0.9}
    .launcher-version{position:fixed;right:10px;bottom:8px;font-size:11px;color:#6f88b5;opacity:0.9;pointer-events:none}
  </style>
</head>
<body>
  <div class="bg"></div>
  <div class="overlay">
    <div class="card">
      <h1 class="title">Nano‑Siege Alpha</h1>
      <p class="subtitle">Reactor Defense Launcher</p>
      <div id="status-line" class="status">Starting launcher…</div>
      <div id="version-line" class="version"></div>
      <div class="signin-wrap">
        <div class="signin-grid">
          <div class="signin-field">
            <label for="login-username">Username</label>
            <input type="text" id="login-username" autocomplete="username" />
          </div>
          <div class="signin-field">
            <label for="login-password">Password</label>
            <input type="password" id="login-password" autocomplete="current-password" />
          </div>
        </div>
        <div class="signin-options">
          <label class="fs-toggle">
            <input type="checkbox" id="login-stay-signedin" />
            <span class="fs-label">Stay signed in on this device</span>
          </label>
        </div>
        <div id="login-status" class="signin-status"></div>
        <div class="buttons" style="margin-top:6px">
          <button id="btn-login" class="secondary">Sign In</button>
        </div>
      </div>
      <div id="dl-wrap" class="dl-wrap" style="display:none">
        <div class="dl-bar"><div id="dl-fill" class="dl-fill"></div></div>
        <div id="dl-text" class="dl-text"></div>
      </div>
      <div class="buttons" id="play-row" style="display:none">
        <button id="btn-play" disabled>Play</button>
        <button id="btn-exit" class="secondary">Exit</button>
      </div>
      <div class="fs-row">
        <label class="fs-toggle">
          <input type="checkbox" id="chk-fullscreen" />
          <span class="fs-label">Launch in fullscreen</span>
        </label>
      </div>
      <div class="footer">The launcher keeps Nano‑Siege up to date automatically.</div>
      <div id="launcher-ver" class="launcher-version"></div>
    </div>
  </div>

  <script>
    const statusEl = document.getElementById('status-line');
    const versionEl = document.getElementById('version-line');
    const playBtn = document.getElementById('btn-play');
    const exitBtn = document.getElementById('btn-exit');
    const dlWrap = document.getElementById('dl-wrap');
    const dlFill = document.getElementById('dl-fill');
    const dlText = document.getElementById('dl-text');
    const fsCheckbox = document.getElementById('chk-fullscreen');
    const loginUserInput = document.getElementById('login-username');
    const loginPasswordInput = document.getElementById('login-password');
    const loginStayCheckbox = document.getElementById('login-stay-signedin');
    const loginStatusEl = document.getElementById('login-status');
    const loginBtn = document.getElementById('btn-login');
    const bgEl = document.querySelector('.bg');
    const http = require('http');
    const https = require('https');
    const fs = require('fs');
    const path = require('path');
    const os = require('os');
    const crypto = require('crypto');
    const { shell } = require('electron');
    const { spawn } = require('child_process');

    const PLATFORM = process.platform === 'win32'
      ? 'windows'
      : (process.platform === 'linux' ? 'linux' : null);

    const DEFAULT_MANIFEST_URL = 'https://nano.nicksminecraft.net/launcher/manifest.json';
    const MANIFEST_URL = process.env.NANO_SIEGE_MANIFEST_URL || DEFAULT_MANIFEST_URL;

    const DEFAULT_META_URL = 'https://nano.nicksminecraft.net/data/meta.json';
    const META_URL = process.env.NANO_SIEGE_META_URL || (() => {
      try {
        const u = new URL(MANIFEST_URL);
        u.pathname = '/data/meta.json';
        u.search = '';
        u.hash = '';
        return u.toString();
      } catch (e) {
        return DEFAULT_META_URL;
      }
    })();
    const DEFAULT_API_BASE = 'https://nano.nicksminecraft.net';
    const API_BASE = (() => {
      try {
        const u = new URL(MANIFEST_URL);
        return u.origin || DEFAULT_API_BASE;
      } catch (e) {
        return DEFAULT_API_BASE;
      }
    })();

    // Prefer a local background video when running as a standalone
    // app so the launcher stays fully functional offline. Fall back
    // to the hosted asset only if the local file is missing.
    const LAUNCHER_BG_URL = (() => {
      try {
        const localPath = path.join(__dirname, 'loading-bg.mp4');
        if (fs.existsSync(localPath)) {
          // Relative path keeps things simple; Electron will resolve
          // this next to launcher.html inside the packaged app.
          return 'loading-bg.mp4';
        }
      } catch (e) {
      }
      try {
        const u = new URL('../data/loading-bg.mp4', MANIFEST_URL);
        return u.toString();
      } catch (e) {
        return 'https://nano.nicksminecraft.net/data/loading-bg.mp4';
      }
    })();

    if (bgEl && LAUNCHER_BG_URL) {
      try {
        const vid = document.createElement('video');
        vid.autoplay = true;
        vid.muted = true;
        vid.loop = true;
        vid.playsInline = true;
        vid.src = LAUNCHER_BG_URL;
        vid.style.position = 'absolute';
        vid.style.inset = '0';
        vid.style.width = '100%';
        vid.style.height = '100%';
        vid.style.objectFit = 'cover';
        vid.style.pointerEvents = 'none';
        bgEl.appendChild(vid);
      } catch (e) {
        // best-effort; background is cosmetic
      }
    }

    function computeMetaUrl(info){
      if (!info || !info.url) return null;
      if (info.metaUrl) return info.metaUrl;
      try{
        return info.url + '.meta.json';
      }catch(e){
        return null;
      }
    }

    function computeHashUrl(info){
      if (!info || !info.url) return null;
      if (info.hashUrl) return info.hashUrl;
      try{
        return info.url + '.sha256';
      }catch(e){
        return null;
      }
    }

    function parseSha256(text){
      if (!text) return null;
      const firstLine = String(text).trim().split('\n')[0].trim();
      if (!firstLine) return null;
      const firstToken = firstLine.split(/\s+/)[0];
      if (!firstToken) return null;
      const hex = firstToken.trim();
      if (!/^[a-fA-F0-9]{32,64}$/.test(hex)) return null;
      return hex.toLowerCase();
    }

    function computeRemoteToken(info, meta, hashInfo){
      if (hashInfo && hashInfo.sha256) {
        return String(hashInfo.sha256).toLowerCase();
      }
      if (meta) {
        if (meta.buildId) return String(meta.buildId);
        if (meta.build) return String(meta.build);
        if (meta.version) return String(meta.version);
        if (meta.etag) return String(meta.etag);
      }
      if (info) {
        if (info.buildId) return String(info.buildId);
        if (info.version) return String(info.version);
        if (info.url) return String(info.url);
      }
      return null;
    }

    function computeDisplayVersion(info, meta, hashInfo){
      if (meta && meta.display) return String(meta.display);
      if (hashInfo && hashInfo.sha256) {
        return String(hashInfo.sha256).slice(0, 8);
      }
      const token = computeRemoteToken(info, meta, hashInfo);
      return token || '';
    }
    function summarizeVersions(localVersion, remoteVersion){
      const local = localVersion ? String(localVersion) : '';
      const remote = remoteVersion ? String(remoteVersion) : '';
      if (local && remote && local !== remote) {
        return local + ' \u2192 ' + remote;
      }
      return remote || local || '';
    }
    const baseDir = path.join(os.homedir(), '.nano-siege');
    const binDir = path.join(baseDir, 'bin');
    const stateFile = path.join(baseDir, 'installed.json');
    const settingsFile = path.join(baseDir, 'launcher-settings.json');

    function readSettings(){
      try{
        const raw = fs.readFileSync(settingsFile, 'utf8');
        const parsed = JSON.parse(raw);
        return {
          launchFullscreen: !!parsed.launchFullscreen,
          rememberedUser: typeof parsed.rememberedUser === 'string'
            ? (parsed.rememberedUser || '').trim() || null
            : null,
          rememberedToken: typeof parsed.rememberedToken === 'string'
            ? (parsed.rememberedToken || '').trim() || null
            : null
        };
      }catch(e){
        return { launchFullscreen:false, rememberedUser:null, rememberedToken:null };
      }
    }

    function writeSettings(next){
      const safe = {
        launchFullscreen: !!(next && next.launchFullscreen),
        rememberedUser: next && typeof next.rememberedUser === 'string'
          ? (next.rememberedUser || '').trim() || null
          : null,
        rememberedToken: next && typeof next.rememberedToken === 'string'
          ? (next.rememberedToken || '').trim() || null
          : null
      };
      fs.mkdirSync(baseDir, { recursive:true });
      fs.writeFileSync(settingsFile, JSON.stringify(safe, null, 2), 'utf8');
    }

    let settings = readSettings();
    let signedInUser = settings && typeof settings.rememberedUser === 'string'
      ? (settings.rememberedUser || '').trim() || null
      : null;
    let signedInToken = settings && typeof settings.rememberedToken === 'string'
      ? (settings.rememberedToken || '').trim() || null
      : null;
    let launcherVersion = null;

    const launcherVersionEl = document.getElementById('launcher-ver');

    try{
      const lv = require('./launcher-version.json');
      if(lv && typeof lv.version === 'string' && lv.version.trim()){
        launcherVersion = lv.version.trim();
      }
    }catch(e){
      launcherVersion = null;
    }
    let currentBinaryPath = null;
    let canPlay = false;
    let hasRunUpdate = false;

    function setStatus(text, version, readyFlag){
      statusEl.textContent = text || '';
      if(version){
        versionEl.textContent = 'Alpha ' + version;
      }else{
        versionEl.textContent = '';
      }
      if(launcherVersionEl){
        launcherVersionEl.textContent = launcherVersion ? ('Launcher v' + launcherVersion) : '';
      }
      const isSignedIn = !!signedInUser;
      const ready = !!readyFlag && isSignedIn;
      canPlay = ready;
      if(playBtn){
        playBtn.disabled = !ready;
      }
    }

    function applyAuthUi(){
      const playRow = document.getElementById('play-row');
      const fsRow = document.querySelector('.fs-row');
      const signinGrid = document.querySelector('.signin-grid');
      const signinOptions = document.querySelector('.signin-options');
      const showControls = !!signedInUser;
      if(playRow){
        playRow.style.display = showControls ? 'flex' : 'none';
      }
      if(fsRow){
        fsRow.style.display = showControls ? 'flex' : 'none';
      }
      // Once signed in, hide the username/password fields and the
      // "stay signed in" checkbox so the launcher surface stays clean.
      if(signinGrid){
        signinGrid.style.display = signedInUser ? 'none' : '';
      }
      if(signinOptions){
        signinOptions.style.display = signedInUser ? 'none' : '';
      }
      if(loginUserInput && signedInUser){
        loginUserInput.value = signedInUser;
      }
      if(loginStayCheckbox){
        loginStayCheckbox.checked = !!(settings && settings.rememberedUser);
      }
      if(loginStatusEl){
        if(signedInUser){
          loginStatusEl.textContent = 'Signed in as ' + signedInUser;
          loginStatusEl.style.color = '#8cf5ff';
        }else{
          loginStatusEl.textContent = '';
          loginStatusEl.style.color = '#9fb7ff';
        }
      }
      if(loginBtn){
        loginBtn.textContent = signedInUser ? 'Sign Out' : 'Sign In';
      }
      if(playBtn){
        // Ensure Play remains disabled until both signed in and the
        // game binary is ready.
        playBtn.disabled = !(canPlay && signedInUser);
      }
    }

    function updateProgressUI(prog){
      if(!dlWrap) return;
      if(!prog){
        dlWrap.style.display = 'none';
        if(dlFill){ dlFill.style.width = '0%'; }
        if(dlText){ dlText.textContent = ''; }
        return;
      }
      dlWrap.style.display = 'block';
      var pct = (typeof prog.percent === 'number') ? prog.percent : 0;
      if(dlFill){
        dlFill.style.width = Math.max(0, Math.min(100, pct)) + '%';
      }
      if(dlText){
        var bytes = prog.downloaded || 0;
        var total = prog.total || 0;
        var mb = (bytes / (1024*1024)).toFixed(2);
        var totalMb = total ? (total / (1024*1024)).toFixed(2) : '?';
        var speedMb = (prog.speedBytesPerSec ? (prog.speedBytesPerSec / (1024*1024)) : 0).toFixed(2);
        var pctLabel = total ? pct.toFixed(1) + '%' : '';
        dlText.textContent = 'Downloading: ' + mb + '/' + totalMb + ' MB' +
          (pctLabel ? ' (' + pctLabel + ')' : '') +
          ' – ' + speedMb + ' MB/s';
      }
    }

    function getHttpModule(url){
      return url.startsWith('https:') ? https : http;
    }

    function postJson(url, payload){
      return new Promise((resolve, reject) => {
        try{
          const target = new URL(url);
          const isHttps = target.protocol === 'https:';
          const mod = isHttps ? https : http;
          const data = JSON.stringify(payload || {});
          const req = mod.request({
            method:'POST',
            hostname: target.hostname,
            port: target.port || (isHttps ? 443 : 80),
            path: target.pathname + (target.search || ''),
            headers:{
              'Content-Type':'application/json',
              'Content-Length': Buffer.byteLength(data)
            }
          }, (res) => {
            const chunks = [];
            res.on('data', (chunk) => chunks.push(chunk));
            res.on('end', () => {
              try{
                const buf = Buffer.concat(chunks);
                let parsed = null;
                try{
                  parsed = JSON.parse(buf.toString('utf8'));
                }catch(e){}
                if(res.statusCode !== 200 || !parsed || parsed.ok === false){
                  const msg = (parsed && parsed.error) ? String(parsed.error) : ('HTTP ' + res.statusCode);
                  return reject(new Error(msg));
                }
                resolve(parsed);
              }catch(e){
                reject(e);
              }
            });
          });
          req.on('error', (err) => reject(err));
          req.write(data);
          req.end();
        }catch(err){
          reject(err);
        }
      });
    }

    function fetchJson(url){
      return new Promise((resolve, reject) => {
        getHttpModule(url)
          .get(url, (res) => {
            if (res.statusCode && res.statusCode >= 300 && res.statusCode < 400 && res.headers.location) {
              return resolve(fetchJson(res.headers.location));
            }
            if (res.statusCode !== 200) {
              return reject(new Error('HTTP ' + res.statusCode + ' for ' + url));
            }
            const chunks = [];
            res.on('data', (c) => chunks.push(c));
            res.on('end', () => {
              try {
                const buf = Buffer.concat(chunks);
                const json = JSON.parse(buf.toString('utf8'));
                resolve(json);
              } catch (e) {
                reject(e);
              }
            });
          })
          .on('error', reject);
      });
    }

    function fetchText(url){
      return new Promise((resolve, reject) => {
        getHttpModule(url)
          .get(url, (res) => {
            if (res.statusCode && res.statusCode >= 300 && res.statusCode < 400 && res.headers.location) {
              return resolve(fetchText(res.headers.location));
            }
            if (res.statusCode !== 200) {
              return reject(new Error('HTTP ' + res.statusCode + ' for ' + url));
            }
            const chunks = [];
            res.on('data', (c) => chunks.push(c));
            res.on('end', () => {
              try{
                const buf = Buffer.concat(chunks);
                resolve(buf.toString('utf8'));
              }catch(e){
                reject(e);
              }
            });
          })
          .on('error', reject);
      });
    }

    function readState(){
      try{
        const raw = fs.readFileSync(stateFile, 'utf8');
        return JSON.parse(raw);
      }catch(e){
        return null;
      }
    }

    function writeState(obj){
      fs.mkdirSync(baseDir, { recursive: true });
      fs.writeFileSync(stateFile, JSON.stringify(obj, null, 2), 'utf8');
    }

    async function fetchRemoteSha(info){
      const hashUrl = computeHashUrl(info);
      if (!hashUrl) return null;
      try{
        const txt = await fetchText(hashUrl);
        const sha = parseSha256(txt);
        if (!sha){
          throw new Error('No SHA256 found in hash file');
        }
        return { hashUrl, sha256: sha };
      }catch(e){
        console.error('Launcher hash fetch failed from', hashUrl, e);
        return null;
      }
    }

    async function fetchGlobalMeta(){
      try{
        const meta = await fetchJson(META_URL);
        if (!meta || typeof meta !== 'object') return null;
        return meta;
      }catch(e){
        console.error('Global meta fetch failed from', META_URL, e);
        return null;
      }
    }

    async function loginWithBackend(username, password){
      const trimmedUser = (username || '').trim();
      const pwd = password || '';
      if(!trimmedUser || !pwd){
        throw new Error('Username and password required');
      }
      const url = API_BASE + '/api/login';
      return postJson(url, { username: trimmedUser, password: pwd });
    }

    function downloadFile(url, dest, onProgress){
      return new Promise((resolve, reject) => {
        fs.mkdirSync(path.dirname(dest), { recursive: true });
        const file = fs.createWriteStream(dest);
        const startedAt = Date.now();
        getHttpModule(url)
          .get(url, (res) => {
            if (res.statusCode && res.statusCode >= 300 && res.statusCode < 400 && res.headers.location) {
              file.close(() => {
                fs.unlink(dest, () => {
                  resolve(downloadFile(res.headers.location, dest, onProgress));
                });
              });
              return;
            }
            if (res.statusCode !== 200) {
              file.close(() => {
              fs.unlink(dest, () => reject(new Error('HTTP ' + res.statusCode + ' for ' + url)));
            });
              return;
            }
            const total = parseInt(res.headers['content-length'] || '0', 10) || 0;
            let downloaded = 0;
            res.on('data', (chunk) => {
              downloaded += chunk.length;
              if (typeof onProgress === 'function') {
                const elapsedSec = Math.max(0.001, (Date.now() - startedAt) / 1000);
                const speed = downloaded / elapsedSec;
                const percent = total > 0 ? (downloaded / total) * 100 : 0;
                try{
                  onProgress({
                    downloaded,
                    total,
                    percent,
                    speedBytesPerSec: speed
                  });
                }catch(e){
                  // Ignore UI update errors.
                }
              }
            });
            res.pipe(file);
            file.on('finish', () => {
              if (typeof onProgress === 'function') {
                try{
                  onProgress({
                    downloaded,
                    total,
                    percent: total > 0 ? 100 : (downloaded > 0 ? 100 : 0),
                    speedBytesPerSec: 0
                  });
                }catch(e){
                  // Ignore.
                }
              }
              file.close(() => resolve(dest));
            });
          })
          .on('error', (err) => {
            file.close(() => {
              fs.unlink(dest, () => reject(err));
            });
          });
      });
    }

    function versionChanged(current, info, meta, hashInfo){
      const token = computeRemoteToken(info, meta, hashInfo);
      if (!token) return true;
      if (!current) return true;
      const curToken = current.sha256 || current.buildToken || current.version || current.urlToken;
      if (!curToken) return true;
      return String(curToken) !== String(token);
    }

    function computeFileSha256(filePath){
      return new Promise((resolve, reject) => {
        const hash = crypto.createHash('sha256');
        const stream = fs.createReadStream(filePath);
        stream.on('error', (err) => reject(err));
        stream.on('data', (chunk) => hash.update(chunk));
        stream.on('end', () => {
          try{
            resolve(hash.digest('hex'));
          }catch(e){
            reject(e);
          }
        });
      });
    }

    async function launchGame(binaryPath){
      if(!binaryPath) return;
      try{
        const launcherUser = signedInUser || null;
        const launcherToken = signedInToken || (settings && settings.rememberedToken) || null;
        const persistAuth = !!(settings && settings.rememberedUser && launcherUser && settings.rememberedUser === launcherUser);
        if(PLATFORM === 'linux'){
          const args = ['--no-sandbox'];
          if(settings && settings.launchFullscreen){
            args.push('--fullscreen');
          }
          if(launcherUser){
            args.push('--nano-user=' + encodeURIComponent(launcherUser));
          }
          if(launcherToken){
            args.push('--nano-token=' + encodeURIComponent(launcherToken));
          }
          if(persistAuth){
            args.push('--nano-stay=1');
          }
          const child = spawn(binaryPath, args, {
            detached: true,
            stdio: 'ignore'
          });
          try{ child.unref(); }catch(e){}
          // Close the launcher immediately after handing off to the game.
          window.close();
          return;
        }
        if(PLATFORM === 'windows'){
          const argsWin = [];
          if(settings && settings.launchFullscreen){
            argsWin.push('--fullscreen');
          }
          if(launcherUser){
            argsWin.push('--nano-user=' + encodeURIComponent(launcherUser));
          }
          if(launcherToken){
            argsWin.push('--nano-token=' + encodeURIComponent(launcherToken));
          }
          if(persistAuth){
            argsWin.push('--nano-stay=1');
          }
          const childWin = spawn(binaryPath, argsWin, {
            detached: true,
            stdio: 'ignore'
          });
          try{ childWin.unref(); }catch(e){}
          window.close();
          return;
        }
        // Fallback: let the OS handle the .exe via the shell.
        const err = await shell.openPath(binaryPath);
        if (err) {
          console.error('Failed to launch game via shell.openPath:', err, 'path:', binaryPath);
          setStatus('Failed to launch game — see console for details.', '', true);
          return;
        }
        window.close();
      }catch(e){
        console.error('Error launching game:', e, 'path:', binaryPath);
        setStatus('Failed to launch game — see console for details.', '', true);
      }
    }

    async function runUpdateFlow(){
      if (!PLATFORM) {
        setStatus('Unsupported platform: ' + process.platform, '', false);
        return;
      }
      if (!signedInUser) {
        setStatus('Sign in to download and play Nano‑Siege.', '', false);
        return;
      }
      try{
        setStatus('Checking for updates…', '', false);
        const manifest = await fetchJson(MANIFEST_URL);
        const info = manifest && manifest[PLATFORM];
        if (!info || !info.url) {
          throw new Error('Manifest missing entry for platform "' + PLATFORM + '" (url required)');
        }

        let meta = null;
        const metaUrl = computeMetaUrl(info);
        if (metaUrl) {
          try{
            meta = await fetchJson(metaUrl);
          }catch(e){
            console.error('Launcher metadata fetch failed from', metaUrl, e);
          }
        }

        const current = readState();
        const hashInfo = await fetchRemoteSha(info);
        const globalMeta = await fetchGlobalMeta();

        // Backfill SHA256 for old installs so they participate in hash-based updates.
        if (current && current.binaryPath && fs.existsSync(current.binaryPath) && !current.sha256) {
          try{
            const sha = await computeFileSha256(current.binaryPath);
            if (sha){
              current.sha256 = sha.toLowerCase();
              writeState(current);
            }
          }catch(e){
            console.error('Failed to compute local SHA256 for existing install:', e);
          }
        }

        const needsUpgrade = versionChanged(current, info, meta, hashInfo);
        const keepPath = current && current.binaryPath && fs.existsSync(current.binaryPath);

        let binaryPath = current && current.binaryPath;
        const displayVersion = computeDisplayVersion(info, meta, hashInfo);
        const remoteGameVersion = (globalMeta && globalMeta.gameVersion) || displayVersion || '';
        const remoteLauncherVersion = (globalMeta && globalMeta.launcherVersion) || null;
        const versionLabel = remoteGameVersion ? (' ' + remoteGameVersion) : (displayVersion ? (' ' + displayVersion) : '');

        const localGameVersion = current
          ? (current.gameVersion || current.displayVersion || (current.sha256 ? String(current.sha256).slice(0, 8) : current.buildToken))
          : '';
        const versionSummary = summarizeVersions(localGameVersion, remoteGameVersion);

        if (needsUpgrade || !keepPath) {
          updateProgressUI(null);
          setStatus('Downloading Nano‑Siege' + versionLabel + '…', versionSummary || remoteGameVersion || displayVersion, false);
          fs.mkdirSync(binDir, { recursive: true });
          const filename = path.basename(new URL(info.url).pathname || 'nano-siege-latest');
          binaryPath = path.join(binDir, filename);
          await downloadFile(info.url, binaryPath, (prog) => {
            updateProgressUI(prog);
          });
          if (PLATFORM === 'linux') {
            try { fs.chmodSync(binaryPath, 0o755); } catch (e) {}
          }
          const buildToken = computeRemoteToken(info, meta, hashInfo);
          let sha256 = hashInfo && hashInfo.sha256;
          if (!sha256) {
            try{
              sha256 = await computeFileSha256(binaryPath);
            }catch(e){
              console.error('Failed to compute SHA256 for downloaded binary:', e);
            }
          }
          writeState({
            platform: PLATFORM,
            buildToken,
            sha256: sha256 ? String(sha256).toLowerCase() : null,
            binaryPath,
            metaUrl,
            hashUrl: hashInfo && hashInfo.hashUrl,
            displayVersion: displayVersion || null,
            gameVersion: remoteGameVersion || displayVersion || null,
            launcherVersion: remoteLauncherVersion || null
          });
          updateProgressUI(null);
          setStatus('Finishing install…', versionSummary || remoteGameVersion || displayVersion, false);
        } else {
          updateProgressUI(null);
          setStatus('Up to date — Nano‑Siege' + versionLabel + ' is installed.', versionSummary || remoteGameVersion || displayVersion, true);
        }

        if (needsUpgrade || !keepPath) {
          setStatus('Ready — Nano‑Siege' + versionLabel + ' installed. Click Play to start.', versionSummary || remoteGameVersion || displayVersion, true);
        }

        currentBinaryPath = binaryPath;
      }catch(err){
        console.error('Launcher error:', err);
        try{
          // If we already have a local install from a previous run,
          // fall back to that even if update checks fail (e.g. server
          // temporarily unreachable) so Play still works.
          const fallback = readState();
          if(fallback && fallback.binaryPath && fs.existsSync(fallback.binaryPath)){
            currentBinaryPath = fallback.binaryPath;
            updateProgressUI(null);
            setStatus('Launcher offline — using existing install.', '', true);
            return;
          }
        }catch(e){
          // ignore fallback errors
        }
        updateProgressUI(null);
        setStatus('Launcher error — see console for details.', '', false);
      }
    }

    applyAuthUi();
    if (signedInUser) {
      hasRunUpdate = true;
      runUpdateFlow();
    } else {
      setStatus('Sign in to download and play Nano‑Siege.', '', false);
    }

    if(loginBtn){
      loginBtn.addEventListener('click', async () => {
        if(!loginUserInput || !loginStatusEl) return;
        // If already signed in, treat this as a sign-out toggle.
        if(signedInUser){
          try{
            signedInUser = null;
            signedInToken = null;
            if(settings){
              settings.rememberedUser = null;
              settings.rememberedToken = null;
              try{ writeSettings(settings); }catch(e){}
            }
            if(loginPasswordInput){
              loginPasswordInput.value = '';
            }
            loginStatusEl.textContent = 'Signed out.';
            loginStatusEl.style.color = '#9fb7ff';
          }catch(e){
            // Best-effort; leave UI in a safe state.
          }
          canPlay = false;
          if(playBtn){
            playBtn.disabled = true;
          }
          currentBinaryPath = null;
          setStatus('Sign in to download and play Nano‑Siege.', '', false);
          applyAuthUi();
          return;
        }
        const username = (loginUserInput.value || '').trim();
        const password = loginPasswordInput ? (loginPasswordInput.value || '') : '';
        if(!username || !password){
          loginStatusEl.textContent = 'Username and password required.';
          loginStatusEl.style.color = '#ff5370';
          return;
        }
        loginStatusEl.textContent = 'Signing in…';
        loginStatusEl.style.color = '#8cf5ff';
        try{
          const result = await loginWithBackend(username, password);
          const resolvedName = (result && typeof result.username === 'string' && result.username.trim())
            ? result.username.trim()
            : username;
          signedInUser = resolvedName;
           const token = (result && typeof result.token === 'string' && result.token.trim())
             ? result.token.trim()
             : null;
           signedInToken = token;
          if(loginStayCheckbox && loginStayCheckbox.checked){
            settings.rememberedUser = resolvedName;
            settings.rememberedToken = token || null;
          }else if(settings){
            settings.rememberedUser = null;
            settings.rememberedToken = null;
          }
          try{
            writeSettings(settings);
          }catch(e){}
          loginStatusEl.textContent = 'Signed in.';
          loginStatusEl.style.color = '#8cf5ff';
          if(!hasRunUpdate){
            hasRunUpdate = true;
            runUpdateFlow();
          }
        }catch(err){
          signedInUser = null;
          signedInToken = null;
          if(loginPasswordInput){
            loginPasswordInput.value = '';
          }
          loginStatusEl.textContent = err && err.message ? err.message : 'Login failed.';
          loginStatusEl.style.color = '#ff5370';
        }
        applyAuthUi();
      });
    }

    if(fsCheckbox){
      fsCheckbox.checked = !!(settings && settings.launchFullscreen);
      fsCheckbox.addEventListener('change', () => {
        settings.launchFullscreen = !!fsCheckbox.checked;
        try{
          writeSettings(settings);
        }catch(e){
          // Ignore persistence errors; preference is optional.
        }
      });
    }

    playBtn.addEventListener('click', async () => {
      if(playBtn.disabled || !canPlay || !currentBinaryPath) return;
      await launchGame(currentBinaryPath);
    });

    exitBtn.addEventListener('click', () => {
      window.close();
    });
  </script>
</body>
</html>
